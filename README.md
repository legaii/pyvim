# Pyvim

### Описание проекта
Консольный текстовый редактор, обладающий базовыми возможностями Vim.

### Стек технологий
* [Python](https://www.python.org/)
* Библиотека [curses](https://docs.python.org/3/library/curses.html)

### Реализуемый функционал
##### Алгоритм работы пользователя с ```Pyvim```:
1. Чтобы открыть файл ```file``` для редактирования, пользователь вводит ```pyvim file``` в командной строке.
2. Пользователь перемещается c помощью команд в режиме ```NORMAL``` в тому месту в тексте, которое он хочет отредактировать.
3. Пользователь переходит в режим ```INSERT``` и вносит изменения, после чего нажимает ```<ESC>``` и возвращается в режим ```NORMAL```.
4. Если пользователь хочет внести еще какие-то изменения, он возвращается к шагу 2.
5. Пользователь сохраняет изменения с помощью команды ```:w<Enter>```.
6. Пользователь выходит из ```Pyvim```  с помощью команды ```:q<Enter>```.
##### Список режимов и доступных в них команд:
* ```NORMAL```. Режим по умолчанию, в котором пользователь использует команды для быстрого перемещения по тексту. Список команд:
  * ```h```, ```j```, ```k``` и ```l``` - переместить курсор влево, вниз, вверх и вправо соответственно.
  * ```w``` - переместить курсор на начало следующего слова
  * ```b``` - переместить курсор на начало предыдущего слова
  * ```0``` - переместить курсор в начало строки
  * ```$``` - переместить курсор в конец строки
  * ```i``` - перейти в режим ```INSERT```
  * ```:``` - перейти в режим ```COMMAND```
  * ```dd``` - удалить текущую строку
  * ```daw``` - удалить текущее слово
  * ```/<text><Enter>``` - найти следующее вхождение ```<text>``` и переместить туда курсор
* ```INSERT```. Текст, который пользователь набирает в этом режиме, вставляется в позицию курсора. Список команд:
  * ```<ESC>``` - перейти в режим ```NORMAL```
* ```COMMAND```. Режим, к котором пользователь может вызывать более сложные команды, принимающие несколько аргументов. После ввода команды необходимо нажать ```<Enter>```, после чего команда выполниться, а пользователь автоматически вернется в режим ```NORMAL```. Список команд:
  * ```e file``` - открыть файл (перед этим нужно сохраниться)
  * ```w``` - сохранить
  * ```w file``` - сохранить как
  * ```q``` - выйти (перед этим нужно сохраниться)
  * ```<ESC>``` - перейти в режим ```NORMAL```

### Архитектура
##### Список классов:

* ```Mode = Enum('Mode', ['NORMAL', 'INSERT', COMMAND'])```

* ```class Buffer:```
  * Атрибуты:
    * ```content: list[str]``` - список строк.
    * ```current_line: int``` - номер строки, где стоит курсор.
    * ```current_char: int``` - номер символа, где стоит курсор.
  * Методы:
    * ```read_from(file: str)``` - считать список строк из ```file``` и передвинуть курсор в начало файла.
    * ```write_to(file: str)``` - записать список строк в ```file```.
    * ```move_line(delta: int)``` - передвинуть курсор на ```delta``` строк.
    * ```move_char(delta: int)``` - передвинуть курсор на ```delta``` символов.
    * ```go_to_next_word()``` - передвинуть курсор на начало следующего слова.
    * ```go_to_prev_word()``` - передвинуть курсор на начало предыдущего слова.
    * ```go_to_line_begin()``` - передвинуть курсор в начало строки.
    * ```go_to_line_end()``` - передвинуть курсор в конец строки.
    * ```insert(string: str)``` - вставить ```string``` под курсор и передвинуть курсор на последний вставленный символ.
    * ```delete_char()``` - удалить символ под курсором.
    * ```delete_word()``` - удалить слово под курсором.
    * ```delete_line()``` - удалить строку под курсором.
    * ```next_occurrence(search_string: str)``` - передвинуть курсор на следующее (то есть начинающееся позже того места, где сейчас стоит курсор) вхождение ```search_string```.

* ```class AppState:```
  * Атрибуты:
    * ```mode: Mode``` - текущий режим.
    * ```file: str``` - путь к последнему файлу, с которым производили чтение или запись.
    * ```buffer: Buffer``` - текущий буфер.
    * ```search_string: str``` - последняя строка, которую искали в тексте.

* ```class KeyBinding:```
  * Атрибуты:
    * ```mode: Mode``` - режим, котором работает данная привязка клавиш.
    * ```pattern: re.Pattern``` - регулярное выражение, которое должен ввести пользователь, чтобы вызвать данную привязку клавиш.
    * ```callback: Callable[[AppState, ...], NoneType]``` - функция, которая вызывается, если пользователь использовал данную привязку клавиш (примечание: эта функция может и должна менять AppState, который ей передали в качестве первого аргумента).
  * Методы:
    * ```check(string: str, app_state: AppState) -> bool``` - если ```app_state.mode == mode``` и ```string``` удовлетворяет регулярному выражению ```pattern```, то вызывается ```callback(app_state, *args)``` и возвращается ```True```, где ```args``` - аргументы, полученные подстановкой ```string``` в регулярное выражение ```pattern```. Если же  ```app_state.mode != mode``` или ```string``` не удовлетворяет ```pattern```, то ничего не происходит и возвращается ```False```.

* ```class AppUI:```
  * Атрибуты:
    * ```state: AppState``` - текущее состояние программы.
    * ```key_binding_prefix: str``` - символы, которые пользователь ввел, но которые еще не были использованы для вызова какой-либо привязки клавиш.
    * ```key_bindings: list[KeyBinding]``` - список привязок клавиш.
  * Методы:
    * ```read_char(char: str)``` - символ ```char``` добавляется в конец ```key_binding_prefix```, после чего последовательно вызывается ```check(key_binding_prefix, state)``` для каждой привязки клавиш из ```key_bindings``` до тех пор, пока один из вызовов ```check``` не вернет ```True```. Если один из вызовов ```check``` вернул ```True```, то ```key_binding_prefix``` очищается, вызывается ```redraw()``` и функция завершается.
    * ```redraw()``` - перерисовать текстовое окно, в котором отображается состояние программы.

